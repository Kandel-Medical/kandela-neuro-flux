<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kandela: Neuro-Flux Protocol</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #050a0f;
            --grid-line: #1a2f38;
            --text-main: #00ff9d;
            --text-dim: #008f58;
            --text-warn: #ffbb00;
            --glow: 0 0 10px rgba(0, 255, 157, 0.5);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        /* Efeito CRT/Scanline subtil */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #ui-layer {
            z-index: 10;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(5, 10, 15, 0.95);
            border-bottom: 1px solid var(--text-dim);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        h1 {
            font-size: 1.1rem;
            margin: 0;
            letter-spacing: 1px;
            color: #fff;
        }

        .subtitle {
            font-size: 0.75rem;
            color: var(--text-main);
            opacity: 0.8;
        }

        .stats {
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-main);
        }

        #game-container {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
        }

        canvas {
            background: radial-gradient(circle at center, #0e1a26 0%, #000000 100%);
            box-shadow: 0 0 25px rgba(0, 255, 157, 0.15);
            border: 1px solid var(--text-dim);
            border-radius: 8px;
            z-index: 5;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 15, 0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            text-align: center;
            backdrop-filter: blur(8px);
            transition: opacity 0.3s;
        }

        .hidden { opacity: 0; pointer-events: none; }

        button {
            background: rgba(0, 255, 157, 0.1);
            border: 1px solid var(--text-main);
            color: var(--text-main);
            padding: 15px 40px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 30px;
            transition: all 0.2s;
            border-radius: 4px;
        }

        button:active {
            background: var(--text-main);
            color: #000;
            box-shadow: 0 0 20px var(--text-main);
        }

        .info-text {
            max-width: 80%;
            line-height: 1.6;
            color: #ccc;
        }

        .highlight { color: var(--text-main); font-weight: bold; }

        #toast {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--text-main);
            padding: 12px 24px;
            border-radius: 4px;
            color: var(--text-main);
            z-index: 40;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
            font-weight: bold;
        }
        
        #toast.error {
            border-color: #ff5555;
            color: #ff5555;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>
            <h1>NEURO-FLUX <span style="font-size:0.6em; vertical-align: super; opacity:0.7">v2.2 (Stable)</span></h1>
            <div class="subtitle" id="level-title">Carregando Módulos...</div>
        </div>
        <div class="stats">
            <div>FLUXO: <span id="coverage">0</span>%</div>
            <div>NVL: <span id="level">1</span></div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="toast">SINAL ESTABILIZADO</div>
    </div>

    <div id="overlay">
        <h2 style="color: var(--text-main); font-size: 2rem; margin-bottom: 5px; text-shadow: var(--glow);">NEURO-FLUX</h2>
        <div style="width: 50px; height: 2px; background: var(--text-main); margin-bottom: 20px;"></div>
        <p class="info-text">
            <span class="highlight">MISSÃO:</span> Restabelecer conexões.<br><br>
            Conecte os pares (Ex: Mediano -> APB).<br>
            <span class="highlight">REGRA DE OURO:</span> O grid deve ficar 100% preenchido. Não deixe espaços vazios.<br>
        </p>
        <button id="startBtn">INICIAR EXAME</button>
    </div>

<script>
/**
 * NEURO-FLUX v2.2 - "Solvable Guarantee"
 * Correção Crítica: Algoritmo de "Multi-Agent Growth" para garantir
 * que todo nível gerado tenha solução de 100% de preenchimento.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const overlay = document.getElementById('overlay');
const coverageDisplay = document.getElementById('coverage');
const levelDisplay = document.getElementById('level');
const levelTitle = document.getElementById('level-title');
const toast = document.getElementById('toast');

const THEMES = [
    {
        name: "MMSS: Condução Motora",
        pairs: [
            ['#FF0055', 'Mediano', 'APB'],    // Vermelho
            ['#00FF9D', 'Ulnar', 'ADM'],      // Verde
            ['#00CCFF', 'Radial', 'EIP'],     // Azul
            ['#FFFF00', 'MuscCut', 'Bíceps'], // Amarelo
            ['#BD00FF', 'Axilar', 'Deltóide']  // Roxo
        ]
    },
    {
        name: "MMII: Motor & Reflexos",
        pairs: [
            ['#BD00FF', 'Fibular', 'EDB'],    // Roxo
            ['#FF8800', 'Tibial', 'AH'],      // Laranja
            ['#FF0055', 'Femoral', 'Quad'],   // Vermelho
            ['#00FF9D', 'H-Reflex', 'Gastroc'],// Verde
            ['#00CCFF', 'Ciático', 'Isquiotibiais']  // Azul
        ]
    },
    {
        name: "MNIO Facial: Músculos e Nervos",
        pairs: [
            ['#BD00FF', 'Frontal', 'Temporal'],    // Roxo
            ['#FF8800', 'OrbOculi', 'Zigomático'],      // Laranja
            ['#FF0055', 'OrbOris', 'Bucal'],   // Vermelho
            ['#00FF9D', 'Mentual', 'Marginal'],// Verde
            ['#00CCFF', 'Trapézio', 'Acessório']  // Azul
        ]
    },
    {
        name: "PESS MS",
        pairs: [
            ['#BD00FF', 'Estímulo', 'Mediano'],    // Roxo
            ['#FF8800', 'PtoErb', 'Perif'],      // Laranja
            ['#FF0055', 'Cerv', 'SubCort'],   // Vermelho
            ['#00FF9D', 'Cp3/Cp4', 'Cortical'] // Verde
        ]
    },
    {
        name: "PESS MI",
        pairs: [
            ['#BD00FF', 'Estímulo', 'Tibial'],    // Roxo
            ['#FF8800', 'FP', 'Perif'],      // Laranja
            ['#FF0055', 'Lombar', 'SubCort'],   // Vermelho
            ['#00FF9D', 'Cpz', 'Cortical'] // Verde
        ]
    },
    {
        name: "Sensitivo & Dermátomos",
        pairs: [
            ['#00CCFF', 'Dedo 2', 'Punho'],   
            ['#FFFF00', 'Dedo 5', 'Punho'],   
            ['#FF8800', 'Sural', 'MalLat'],   
            ['#BD00FF', 'Radial', 'Tabac'],
            ['#FF0055', 'Safeno', 'MalMed']
        ]
    }
];

// Estado
let gridSize = 5;
let cellSize = 0;
let grid = []; 
let currentLevel = 1;
let currentTheme = null;
let activePairs = []; 
let paths = []; 

// Interação
let isDrawing = false;
let activePairIndex = -1;
let lastCell = null;

class Cell {
    constructor(r, c) {
        this.r = r;
        this.c = c;
        this.pairIndex = -1; 
        this.isEndpoint = false;
        this.isStart = false; 
        this.links = { top: false, right: false, bottom: false, left: false };
    }
    
    reset() {
        if (!this.isEndpoint) {
            this.pairIndex = -1;
        }
        this.links = { top: false, right: false, bottom: false, left: false };
    }
}

function initGame() {
    grid = Array(5).fill().map((_, r) => Array(5).fill().map((_, c) => new Cell(r, c)));
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    const startEvents = ['mousedown', 'touchstart'];
    const moveEvents = ['mousemove', 'touchmove'];
    const endEvents = ['mouseup', 'mouseleave', 'touchend'];

    startEvents.forEach(evt => canvas.addEventListener(evt, handleStart, {passive: false}));
    moveEvents.forEach(evt => canvas.addEventListener(evt, handleMove, {passive: false}));
    endEvents.forEach(evt => canvas.addEventListener(evt, handleEnd));

    startBtn.addEventListener('click', () => {
        overlay.classList.add('hidden');
        startLevel(1);
    });

    if (window.Telegram && window.Telegram.WebApp) {
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();
    }
}

function resizeCanvas() {
    const container = document.getElementById('game-container');
    const size = Math.min(container.clientWidth, container.clientHeight) * 0.95;
    canvas.width = size;
    canvas.height = size;
    cellSize = size / gridSize;
    draw();
}

function startLevel(lvl) {
    currentLevel = lvl;
    levelDisplay.innerText = lvl;
    const themeIdx = (lvl - 1) % THEMES.length;
    currentTheme = THEMES[themeIdx];
    levelTitle.innerText = currentTheme.name;

    let size = 5;
    let numPairs = 3; 

    // Curva de Dificuldade
    if (lvl > 2) { size = 5; numPairs = 4; }
    if (lvl > 5) { size = 6; numPairs = 4; }
    if (lvl > 8) { size = 6; numPairs = 5; }
    if (lvl > 12) { size = 7; numPairs = 5; }

    activePairs = currentTheme.pairs.slice(0, numPairs);
    paths = Array(numPairs).fill().map(() => []);

    // Tenta gerar até conseguir um nível válido (solúvel)
    let success = false;
    let attempts = 0;
    while (!success && attempts < 200) {
        success = generateMultiAgentLevel(size, numPairs);
        attempts++;
    }

    if (!success) {
        console.error("Falha ao gerar nível complexo, fallback para simples.");
        generateMultiAgentLevel(5, 3); // Fallback seguro
    }
    
    draw();
    showToastMsg("Nível " + currentLevel, false);
}

/**
 * ALGORITMO DE GERAÇÃO ROBUSTO (Multi-Agent Random Walk)
 * 1. Posiciona N agentes (Heads) no grid.
 * 2. Faz eles crescerem simultaneamente para ocupar o espaço vazio.
 * 3. Se o grid encher 100%, o nível é válido.
 * 4. Define as pontas dos caminhos gerados como Start/End.
 * 5. Limpa o "miolo" para o jogador resolver.
 */
function generateMultiAgentLevel(size, numPairs) {
    gridSize = size;
    cellSize = canvas.width / gridSize;
    grid = [];
    paths = Array(numPairs).fill().map(() => []);
    
    // 1. Cria Grid Vazio
    for(let r=0; r<size; r++) {
        let row = [];
        for(let c=0; c<size; c++) row.push(new Cell(r, c));
        grid.push(row);
    }

    // Mapa temporário para geração: armazena qual par ocupa qual célula (-1 = livre)
    let layout = Array(size).fill().map(() => Array(size).fill(-1));
    let heads = []; // Posição atual da cabeça de cada cobra
    let snakeLengths = Array(numPairs).fill(1);

    // 2. Posiciona Cabeças Iniciais Aleatórias
    let available = [];
    for(let r=0; r<size; r++) for(let c=0; c<size; c++) available.push({r,c});
    
    // Shuffle
    available.sort(() => Math.random() - 0.5);

    for(let i=0; i<numPairs; i++) {
        if(available.length === 0) return false;
        let pos = available.pop();
        layout[pos.r][pos.c] = i; // Marca cor
        heads.push(pos);
    }

    // 3. Loop de Crescimento (Expansão de Domínio)
    let stuck = Array(numPairs).fill(false);
    let totalCells = size * size;
    let filledCells = numPairs; // Já colocamos as cabeças

    while(filledCells < totalCells) {
        let movedAny = false;
        
        // Tenta mover cada cobra uma vez (Round Robin)
        // Randomiza ordem para não privilegiar a primeira cor
        let order = Array.from({length: numPairs}, (_, k) => k).sort(() => Math.random() - 0.5);

        for (let i of order) {
            if (stuck[i]) continue;

            let h = heads[i];
            let neighbors = [
                {r: h.r-1, c: h.c}, {r: h.r+1, c: h.c},
                {r: h.r, c: h.c-1}, {r: h.r, c: h.c+1}
            ].filter(n => 
                n.r >= 0 && n.r < size && n.c >= 0 && n.c < size && layout[n.r][n.c] === -1
            );

            if (neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                layout[next.r][next.c] = i;
                heads[i] = next; // Move a cabeça
                snakeLengths[i]++;
                filledCells++;
                movedAny = true;
            } else {
                stuck[i] = true;
            }
        }

        // Se ninguém moveu e ainda tem espaço vazio, falhou (buracos inacessíveis)
        if (!movedAny && filledCells < totalCells) {
            return false; 
        }
    }

    // 4. Validação Final
    // Garante que nenhuma cobra ficou minúscula (ex: comprimento < 3 fica chato)
    if (snakeLengths.some(l => l < 3)) return false;

    // 5. Transfere Layout para o Grid do Jogo
    // Precisamos encontrar as "pontas" de cada cluster gerado para serem os endpoints.
    // O algoritmo acima gera cobras lineares? Não necessariamente, gera árvores.
    // Para este jogo (Flow), precisamos de caminhos lineares (sem bifurcação).
    // O método "Worm" simples gera linhas, mas falha em preencher.
    // O método "Multi-Agent Growth" gera territórios.
    // Simplificação para MVP: Vamos assumir que a cabeça final e a inicial são os endpoints.
    // Isso funciona se o caminho não se ramificou. Nosso growth moveu a cabeça, então é linear!
    // Só precisamos recuperar onde foi o START de cada um.
    
    // Recalcula starts (infelizmente perdi no loop acima, vamos reconstruir ou guardar antes)
    // Ops, heads[] mudou. Vamos guardar starts[] no inicio.
    
    // RESTART da lógica com armazenamento correto:
    // (Para não duplicar código, vou assumir que heads[] agora é o END, preciso do START).
    // Mas espere, o growth acima é linear simples (cobra que anda). 
    // O rastro é o corpo. A cabeça move. Então é um caminho único. Perfeito.
    
    // Precisamos saber onde COMEÇOU.
    // Vamos fazer o passo 2 de novo mentalmente:
    // As posições iniciais em 'available' eram os starts.
    // Vamos refazer a estrutura para guardar caminhos.
    
    return false; // Força retry para usar a função corrigida abaixo (apenas hack estrutural)
}

// Função REAIS de Geração (Substituindo a lógica acima dentro da mesma função para clareza)
// Sobrescrevendo a anterior com a lógica completa:
generateMultiAgentLevel = function(size, numPairs) {
    let newGrid = Array(size).fill().map(() => Array(size).fill(-1));
    let pathsData = Array(numPairs).fill().map(() => []); // Array de coordenadas {r,c}
    
    // 1. Escolhe Starts
    let available = [];
    for(let r=0; r<size; r++) for(let c=0; c<size; c++) available.push({r,c});
    available.sort(() => Math.random() - 0.5);

    for(let i=0; i<numPairs; i++) {
        let pos = available.pop();
        newGrid[pos.r][pos.c] = i;
        pathsData[i].push(pos); // O primeiro elemento é o Start
    }

    // 2. Cresce
    let filledCount = numPairs;
    let stuck = Array(numPairs).fill(false);
    let active = true;

    while(active && filledCount < size*size) {
        active = false;
        // Sorteia ordem para ser justo
        let order = Array.from({length: numPairs}, (_, k) => k).sort(() => Math.random() - 0.5);
        
        for(let i of order) {
            if(stuck[i]) continue;
            
            // Pega a ponta atual (cabeça)
            let head = pathsData[i][pathsData[i].length - 1];
            
            let neighbors = [
                {r: head.r-1, c: head.c}, {r: head.r+1, c: head.c},
                {r: head.r, c: head.c-1}, {r: head.r, c: head.c+1}
            ].filter(n => 
                n.r >= 0 && n.r < size && n.c >= 0 && n.c < size && newGrid[n.r][n.c] === -1
            );

            if(neighbors.length > 0) {
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                newGrid[next.r][next.c] = i;
                pathsData[i].push(next);
                filledCount++;
                active = true;
            } else {
                stuck[i] = true;
            }
        }
    }

    // 3. Validações
    if(filledCount < size*size) return false; // Não preencheu tudo
    if(pathsData.some(p => p.length < 3)) return false; // Caminhos muito curtos

    // 4. Aplica ao Grid Real
    gridSize = size;
    cellSize = canvas.width / gridSize;
    grid = [];
    
    for(let r=0; r<size; r++) {
        let row = [];
        for(let c=0; c<size; c++) row.push(new Cell(r, c));
        grid.push(row);
    }

    for(let i=0; i<numPairs; i++) {
        let p = pathsData[i];
        let start = p[0];
        let end = p[p.length-1];

        // Configura Start
        grid[start.r][start.c].isEndpoint = true;
        grid[start.r][start.c].isStart = true;
        grid[start.r][start.c].pairIndex = i;

        // Configura End
        grid[end.r][end.c].isEndpoint = true;
        grid[end.r][end.c].isStart = false;
        grid[end.r][end.c].pairIndex = i;
        
        // Limpa o meio (o jogador deve descobrir)
        // As células do meio ficam vazias (pairIndex -1)
    }

    return true;
}


// --- Lógica de Input e Pathfinding ---
function getPos(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const c = Math.floor((clientX - rect.left) / cellSize);
    const r = Math.floor((clientY - rect.top) / cellSize);
    return {r, c};
}

function handleStart(e) {
    const pos = getPos(e);
    if(pos.r < 0 || pos.r >= gridSize || pos.c < 0 || pos.c >= gridSize) return;
    
    const cell = grid[pos.r][pos.c];

    if (cell.pairIndex !== -1) {
        isDrawing = true;
        activePairIndex = cell.pairIndex;
        
        if (cell.isEndpoint) {
            clearPath(activePairIndex);
            paths[activePairIndex] = [cell];
            lastCell = cell;
        } else {
            // Logica de retomar caminho
            const pathArr = paths[activePairIndex];
            const idx = pathArr.indexOf(cell);
            
            if (idx !== -1) {
                for (let i = idx + 1; i < pathArr.length; i++) {
                    const c = pathArr[i];
                    if(!c.isEndpoint) c.reset();
                    else c.links = { top: false, right: false, bottom: false, left: false };
                }
                paths[activePairIndex] = pathArr.slice(0, idx + 1);
                cell.links = { top: false, right: false, bottom: false, left: false };
                if (idx > 0) linkCells(pathArr[idx-1], cell);
                lastCell = cell;
            } else {
                isDrawing = false;
            }
        }
        draw();
    }
}

function handleMove(e) {
    if (!isDrawing || !lastCell) return;
    const pos = getPos(e);
    if(pos.r < 0 || pos.r >= gridSize || pos.c < 0 || pos.c >= gridSize) return;

    const cell = grid[pos.r][pos.c];

    if (cell !== lastCell) {
        const dr = Math.abs(cell.r - lastCell.r);
        const dc = Math.abs(cell.c - lastCell.c);
        if (dr + dc !== 1) return; 

        // Colisões
        if (cell.isEndpoint && cell.pairIndex !== activePairIndex) return;
        if (!cell.isEndpoint && cell.pairIndex !== -1 && cell.pairIndex !== activePairIndex) return;

        // Backtracking
        const currentPath = paths[activePairIndex];
        if (currentPath.length > 1 && currentPath[currentPath.length - 2] === cell) {
            if (!lastCell.isEndpoint) lastCell.reset();
            else lastCell.links = { top: false, right: false, bottom: false, left: false };
            currentPath.pop();
            lastCell = cell;
            cell.links = { top: false, right: false, bottom: false, left: false };
            if (currentPath.length > 1) linkCells(currentPath[currentPath.length - 2], cell);
            draw();
            return;
        }

        if (currentPath.includes(cell)) return; 

        // Avançar
        cell.pairIndex = activePairIndex;
        linkCells(lastCell, cell);
        currentPath.push(cell);
        lastCell = cell;
        draw();
        
        if (cell.isEndpoint) {
            isDrawing = false; 
            checkWinCondition();
        }
    }
}

function linkCells(c1, c2) {
    if (c1.r === c2.r) { 
        if (c1.c < c2.c) { c1.links.right = true; c2.links.left = true; }
        else { c1.links.left = true; c2.links.right = true; }
    } else { 
        if (c1.r < c2.r) { c1.links.bottom = true; c2.links.top = true; }
        else { c1.links.top = true; c2.links.bottom = true; }
    }
}

function handleEnd() {
    if (isDrawing) {
        isDrawing = false;
        checkWinCondition();
    }
}

function clearPath(pIdx) {
    for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
            if(grid[r][c].pairIndex === pIdx) {
                grid[r][c].links = { top: false, right: false, bottom: false, left: false };
                if(!grid[r][c].isEndpoint) grid[r][c].pairIndex = -1;
            }
        }
    }
    paths[pIdx] = []; 
}

function checkWinCondition() {
    let filledCells = 0;
    let totalCells = gridSize * gridSize;
    let allConnected = true;

    for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
            if(grid[r][c].pairIndex !== -1) filledCells++;
        }
    }
    
    for (let i = 0; i < activePairs.length; i++) {
        const p = paths[i];
        if (p.length < 2) { allConnected = false; break; }
        const start = p[0];
        const end = p[p.length-1];
        if (!start.isEndpoint || !end.isEndpoint || start === end) {
            allConnected = false; break;
        }
    }

    let percent = Math.floor((filledCells / totalCells) * 100);
    coverageDisplay.innerText = percent;

    if (allConnected) {
        if (percent === 100) {
            showToastMsg("SISTEMA SINCRONIZADO!", false);
            setTimeout(() => {
                startLevel(currentLevel + 1);
            }, 1500);
        } else {
            showToastMsg("CIRCUITO INCOMPLETO: Ocupe os espaços vazios!", true);
        }
    }
}

function showToastMsg(msg, isError) {
    toast.innerText = msg;
    toast.className = isError ? 'error' : '';
    toast.style.opacity = 1;
    clearTimeout(window.toastTimer);
    window.toastTimer = setTimeout(() => { toast.style.opacity = 0; }, 2500);
}

function draw() {
    ctx.fillStyle = '#050a0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!grid || grid.length === 0) return;

    // Grid
    ctx.strokeStyle = '#1a2f38';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<=gridSize; i++) {
        ctx.moveTo(i * cellSize, 0); ctx.lineTo(i * cellSize, canvas.height);
        ctx.moveTo(0, i * cellSize); ctx.lineTo(canvas.width, i * cellSize);
    }
    ctx.stroke();

    // Paths
    ctx.lineCap = 'round';
    
    for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
            const cell = grid[r][c];
            if (cell.pairIndex !== -1) {
                const color = activePairs[cell.pairIndex][0];
                const cx = c * cellSize + cellSize/2;
                const cy = r * cellSize + cellSize/2;
                const halfCell = cellSize / 2;
                const pipeWidth = cellSize * 0.4;

                ctx.strokeStyle = color;
                ctx.lineWidth = pipeWidth;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                if (cell.links.right) { ctx.moveTo(cx, cy); ctx.lineTo(cx + halfCell, cy); }
                if (cell.links.left) { ctx.moveTo(cx, cy); ctx.lineTo(cx - halfCell, cy); }
                if (cell.links.bottom) { ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + halfCell); }
                if (cell.links.top) { ctx.moveTo(cx, cy); ctx.lineTo(cx, cy - halfCell); }
                ctx.stroke();
                
                if (Object.values(cell.links).some(v=>v)) {
                     ctx.fillStyle = color;
                     ctx.beginPath();
                     ctx.arc(cx, cy, pipeWidth/2, 0, Math.PI*2);
                     ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }
    }

    // Endpoints
    for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
            let cell = grid[r][c];
            if(cell.isEndpoint) {
                const pairData = activePairs[cell.pairIndex];
                const color = pairData[0];
                const label = cell.isStart ? pairData[1] : pairData[2]; 

                let cx = c * cellSize + cellSize/2;
                let cy = r * cellSize + cellSize/2;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, cellSize * 0.35, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                let fontSize = Math.floor(cellSize * 0.22); 
                ctx.font = `bold ${fontSize}px 'Share Tech Mono'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(label, cx, cy);
                ctx.fillText(label, cx, cy);
            }
        }
    }
}

initGame();

</script>
</body>
</html>
